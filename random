import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# ----- Quantile binning on score_raw_weighted -----
n_bins = 4  # target number of bins

# Get codes (0..k-1) and the actual edges; allow duplicates to drop
codes, bin_edges = pd.qcut(
    df["score_raw_weighted"],
    q=n_bins,
    labels=False,         # return integer codes instead of labels
    retbins=True,
    duplicates="drop"     # collapse bins when edges are equal
)

# Convert to 1..k labels
df["score_quantile_bin"] = pd.Series(codes, index=df.index).astype(int) + 1
actual_bins = len(bin_edges) - 1
bin_labels = list(range(1, actual_bins + 1))

# Count PLIs per bin (if no 'pli' column, this will just count rows)
if "pli" in df.columns:
    pli_counts = (
        df.groupby("score_quantile_bin")["pli"].nunique()
          .reindex(bin_labels, fill_value=0)
    )
else:
    pli_counts = (
        df["score_quantile_bin"].value_counts().sort_index()
          .reindex(bin_labels, fill_value=0)
    )

# Print ranges + counts
print("\nQuantile bins on score_raw_weighted (actual bins={}):".format(actual_bins))
for i in range(actual_bins):
    lo, hi = bin_edges[i], bin_edges[i+1]
    print(f"  Bin {i+1}: {lo:.2f} to {hi:.2f} | PLI count: {int(pli_counts.iloc[i])}")

# Plot
plt.figure(figsize=(6,4))
bars = plt.bar(pli_counts.index.astype(int), pli_counts.values.astype(int))
plt.title("PLIs per Quantile Bin of score_raw_weighted")
plt.xlabel(f"Quantile bin (1 = lowest, {actual_bins} = highest)")
plt.ylabel("PLI count")
for b in bars:
    h = b.get_height()
    plt.text(b.get_x()+b.get_width()/2, h + max(1, pli_counts.values.max())*0.02,
             f"{int(h)}", ha="center", va="bottom", fontsize=9)
plt.tight_layout()
plt.show()

