import pandas as pd
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, r2_score
from sklearn.preprocessing import LabelEncoder

# Load your Excel file (update path if needed)
file_path = "your_file.xlsx"
df = pd.read_excel(file_path)

# --- Step 1: Select Columns ---
features = [
    'browser_access_flag',
    'jpm_lockbox_image_file_flag',
    'non_jpm_lockbox_image_file_flag',
    'self_scanning_lockbox_image_file_flag',
    'pdf_image_file_to_835_flag',
    'patient_payment_flag',
    'paper_eob_conversion_to_835_flag',
    '835_outbound_transmission_commercial_era_uploading_flag',
    'epic_cash_management_file_flag',
    '835_outbound_transmission_commercial_flag',
    '835_outbound_transmission_patientpay_flag',
    'outbound_hcl_image_transmission_flag',
    'reconciliation_manager_flag',
    'reconciliation_manager_enterprise_flag',
    'corr_index_flag',
    '835_packet_split_flag',
    'pli_type',
    'prod_tx'
]
target = 'pli_active_cycle_time'

# --- Step 2: Drop rows with missing target ---
df = df.dropna(subset=[target])

# --- Step 3: Encode categorical features ---
df['pli_type'] = LabelEncoder().fit_transform(df['pli_type'].astype(str))
df['prod_tx'] = LabelEncoder().fit_transform(df['prod_tx'].astype(str))

# --- Step 4: Convert True/False to 1/0 ---
for col in features:
    if df[col].dtype == 'bool' or df[col].dtype == 'object':
        df[col] = df[col].astype(str).str.upper().replace({'TRUE': 1, 'FALSE': 0})

# --- Step 5: Train/Test Split ---
X = df[features]
y = df[target]
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# --- Step 6: Random Forest Regressor ---
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)
y_pred = model.predict(X_test)

# --- Step 7: Metrics ---
mae = mean_absolute_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)
print(f"Random Forest MAE: {mae:.2f} days")
print(f"R¬≤ Score: {r2:.2f}")

# --- Step 8: Feature Importance ---
importances = pd.Series(model.feature_importances_, index=features).sort_values(ascending=False)
print("\nTop Feature Importances:")
print(importances)
pip install pandas scikit-learn openpyxl
import pandas as pd
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, r2_score
from sklearn.preprocessing import LabelEncoder

# Load Excel data
file_path = "your_file.xlsx"  # ‚Üê Update this path
df = pd.read_excel(file_path)

# Select features and target
features = [
    'browser_access_flag',
    'jpm_lockbox_image_file_flag',
    'non_jpm_lockbox_image_file_flag',
    'self_scanning_lockbox_image_file_flag',
    'pdf_image_file_to_835_flag',
    'patient_payment_flag',
    'paper_eob_conversion_to_835_flag',
    '835_outbound_transmission_commercial_era_uploading_flag',
    'epic_cash_management_file_flag',
    '835_outbound_transmission_commercial_flag',
    '835_outbound_transmission_patientpay_flag',
    'outbound_hcl_image_transmission_flag',
    'reconciliation_manager_flag',
    'reconciliation_manager_enterprise_flag',
    'corr_index_flag',
    '835_packet_split_flag',
    'pli_type',
    'prod_tx'
]
target = 'pli_active_cycle_time'

# Drop rows with missing target
df = df.dropna(subset=[target])

# Encode categorical variables
df['pli_type'] = LabelEncoder().fit_transform(df['pli_type'].astype(str))
df['prod_tx'] = LabelEncoder().fit_transform(df['prod_tx'].astype(str))

# Convert TRUE/FALSE to 1/0
for col in features:
    if df[col].dtype == 'bool' or df[col].dtype == 'object':
        df[col] = df[col].astype(str).str.upper().replace({'TRUE': 1, 'FALSE': 0})

# Split into train/test sets
X = df[features]
y = df[target]
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train Linear Regression model
model = LinearRegression()
model.fit(X_train, y_train)
y_pred = model.predict(X_test)

# Evaluation metrics
mae = mean_absolute_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)
print(f"Linear Regression MAE: {mae:.2f} days")
print(f"R¬≤ Score: {r2:.2f}")

# Coefficients
coefficients = pd.Series(model.coef_, index=features)
print("\nFeature Coefficients:")
print(coefficients.sort_values(ascending=False))
------
import pandas as pd
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import MinMaxScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import KBinsDiscretizer

# Load Excel file (update path as per your local machine)
df = pd.read_excel("your_excel_file.xlsx")  # üëà Replace with actual filename

# Drop any row with missing target
df = df.dropna(subset=["pli_active_cycle_time"])

# Define features and target
features = [
    "browser_access_flag", "jpm_lockbox_image_file_flag", "non_jpm_lockbox_image_file_flag",
    "self_scanning_lockbox_image_file_flag", "pdf_image_file_to_835_flag", "patient_payment_flag",
    "paper_eob_conversion_to_835_flag", "835_outbound_transmission_commercial_era_uploading_flag",
    "epic_cash_management_file_flag", "835_outbound_transmission_commercial_flag",
    "835_outbound_transmission_patientpay_flag", "outbound_hcl_image_transmission_flag",
    "reconciliation_manager_flag", "reconciliation_manager_enterprise_flag", "corr_index_flag",
    "835_packet_split_flag", "pli_type", "prod_tx", "fispan_flag", "grade"
]
target = "pli_active_cycle_time"

# Split into X and y
X = df[features]
y = df[target]

# Separate categorical and numeric columns
categorical_features = ["pli_type", "prod_tx", "grade"]
numeric_features = list(set(features) - set(categorical_features))

# Preprocessing pipeline
preprocessor = ColumnTransformer(
    transformers=[
        ("num", MinMaxScaler(), numeric_features),
        ("cat", OneHotEncoder(drop='first'), categorical_features)
    ]
)

# Build linear regression pipeline
pipeline = Pipeline(steps=[
    ("preprocessor", preprocessor),
    ("regressor", LinearRegression())
])

# Fit model
pipeline.fit(X, y)

# Predict cycle time
y_pred = pipeline.predict(X)

# Convert predicted cycle time to complexity score (1-5)
binning = KBinsDiscretizer(n_bins=5, encode='ordinal', strategy='quantile')
complexity_score = binning.fit_transform(y_pred.reshape(-1, 1)).astype(int) + 1

# Add to dataframe
df["predicted_cycle_time"] = y_pred
df["complexity_score"] = complexity_score

# Export to Excel
df.to_excel("pli_with_complexity_scores.xlsx", index=False)
print("‚úÖ Output saved as 'pli_with_complexity_scores.xlsx'")


------

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import MinMaxScaler, OneHotEncoder, KBinsDiscretizer
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, r2_score

# Load your actual Excel file here
df = pd.read_excel("your_excel_file.xlsx")  # üîÅ Replace with actual file path

# Drop rows where target is missing
df = df.dropna(subset=["pli_active_cycle_time"])

# Define the features and target
features = [
    "browser_access_flag", "jpm_lockbox_image_file_flag", "non_jpm_lockbox_image_file_flag",
    "self_scanning_lockbox_image_file_flag", "pdf_image_file_to_835_flag", "patient_payment_flag",
    "paper_eob_conversion_to_835_flag", "835_outbound_transmission_commercial_era_uploading_flag",
    "epic_cash_management_file_flag", "835_outbound_transmission_commercial_flag",
    "835_outbound_transmission_patientpay_flag", "outbound_hcl_image_transmission_flag",
    "reconciliation_manager_flag", "reconciliation_manager_enterprise_flag", "corr_index_flag",
    "835_packet_split_flag", "pli_type", "prod_tx", "fispan_flag", "grade"
]
target = "pli_active_cycle_time"

# Split features and target
X = df[features]
y = df[target]

# Identify categorical and numeric columns
categorical_features = ["pli_type", "prod_tx", "grade"]
numeric_features = list(set(features) - set(categorical_features))

# Preprocessing: scale numerics, encode categoricals
preprocessor = ColumnTransformer([
    ("num", MinMaxScaler(), numeric_features),
    ("cat", OneHotEncoder(drop='first'), categorical_features)
])

# Pipeline with linear regression
pipeline = Pipeline([
    ("preprocessor", preprocessor),
    ("regressor", LinearRegression())
])

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train model
pipeline.fit(X_train, y_train)

# Predict for full dataset
df["predicted_cycle_time"] = pipeline.predict(X)

# Calculate complexity score bins (1‚Äì5)
binning = KBinsDiscretizer(n_bins=5, encode='ordinal', strategy='quantile')
df["complexity_score"] = binning.fit_transform(df[["predicted_cycle_time"]]).astype(int) + 1

# üìà Chart 1: Actual vs Predicted
plt.figure(figsize=(8, 5))
sns.scatterplot(x="pli_active_cycle_time", y="predicted_cycle_time", data=df)
plt.plot([df["pli_active_cycle_time"].min(), df["pli_active_cycle_time"].max()],
         [df["pli_active_cycle_time"].min(), df["pli_active_cycle_time"].max()],
         color="red", linestyle="--")
plt.title("Actual vs Predicted Cycle Time")
plt.xlabel("Actual")
plt.ylabel("Predicted")
plt.grid(True)
plt.tight_layout()
plt.show()

# üìä Chart 2: Complexity Score Distribution
plt.figure(figsize=(6, 4))
sns.countplot(x="complexity_score", data=df)
plt.title("Distribution of Complexity Scores")
plt.xlabel("Complexity Score (1 = Low, 5 = High)")
plt.ylabel("Count")
plt.tight_layout()
plt.show()

# üî• Chart 3: Correlation Heatmap
plt.figure(figsize=(6, 4))
sns.heatmap(df[['pli_active_cycle_time', 'predicted_cycle_time', 'complexity_score']].corr(), annot=True, cmap='coolwarm')
plt.title("Correlation Matrix")
plt.tight_layout()
plt.show()

# üíæ Optional: Save result with scores
df.to_excel("pli_with_predictions_and_scores.xlsx", index=False)
print("‚úÖ Saved output to 'pli_with_predictions_and_scores.xlsx'")

